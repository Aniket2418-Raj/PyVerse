#Streamline
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Linear flow matrix A and velocity function
A = np.array([[0.5, -1.0], [1.0, -0.2]])
def flow(t, xy): return A @ xy

# Integrate streamline from starting point
start = [2, 1]
t = np.linspace(0, 10, 500)
sol = solve_ivp(flow, (t[0], t[-1]), start, t_eval=t)
X, Y = sol.y

# Pick a point for tangent
i = 200
x0, y0 = X[i], Y[i]
u, v = flow(0, [x0, y0])
m = v / u

# Tangent line
dx = 1
tx = [x0 - dx, x0 + dx]
ty = [y0 - m*dx, y0 + m*dx]

# Plot
plt.figure(figsize=(6,6))
plt.plot(X, Y, 'b', label='Streamline')
plt.plot(tx, ty, 'r--', label=f'Tangent (slope={m:.2f})')
plt.scatter(x0, y0, color='k')
plt.axis('equal'); plt.grid(True); plt.legend()
plt.xlabel("x"); plt.ylabel("y")
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Flow parameters
U = 0.5
A = 4.0
omega = 1.0
sigma = 0.8

def eddy_strength(t):
    return np.sin(omega * t)

def velocity(x, y, t):
    r2 = x**2 + y**2
    a = A * eddy_strength(t)
    factor = np.exp(-r2 / (2 * sigma**2))
    u = U + (-a * y) * factor
    v = (a * x) * factor
    return u, v

def rk4_step(x, y, t, dt):
    k1x, k1y = velocity(x, y, t)
    k2x, k2y = velocity(x + 0.5*dt*k1x, y + 0.5*dt*k1y, t + 0.5*dt)
    k3x, k3y = velocity(x + 0.5*dt*k2x, y + 0.5*dt*k2y, t + 0.5*dt)
    k4x, k4y = velocity(x + dt*k3x, y + dt*k3y, t + dt)
    xn = x + dt*(k1x + 2*k2x + 2*k3x + k4x)/6.0
    yn = y + dt*(k1y + 2*k2y + 2*k3y + k4y)/6.0
    return xn, yn

# Domain and time settings
xmin, xmax, ymin, ymax = -3.0, 5.0, -3.0, 3.0
dt = 0.005
t0, t_end = 0.0, 8.0
# -------------------- PATHLINES --------------------
particles0 = [(-2.5, -1.5), (-2.0, 0.5), (-1.0, 1.5), (0.0, -2.0), (0.5, 1.0), (1.5, 0.0)]
nsteps = int((t_end - t0)/dt) + 1

plt.figure(figsize=(10,6))
plt.title("Pathlines - Modified Flow")
plt.xlabel("x"); plt.ylabel("y")
for (x0, y0) in particles0:
    xs = [x0]; ys = [y0]
    x, y = x0, y0
    t = t0
    for _ in range(nsteps-1):
        x, y = rk4_step(x, y, t, dt)
        t += dt
        xs.append(x); ys.append(y)
    plt.plot(xs, ys, linewidth=1)
    plt.scatter(xs[0], ys[0], s=24)
plt.scatter([0.0], [0.0], marker='x', s=60)
plt.xlim(xmin, xmax); plt.ylim(ymin, ymax)
plt.gca().set_aspect('equal', adjustable='box')
plt.grid(alpha=0.25)
plt.tight_layout()
plt.show()

# -------------------- STREAKLINE --------------------
source = (-2.0, 0.5)
t_obs = 5.0
n_releases = 200
release_times = np.linspace(0.0, t_obs, n_releases)
streak_positions = []

for tr in release_times:
    x, y = source
    t = tr
    nsteps_local = int(np.ceil((t_obs - tr) / dt))
    for _ in range(nsteps_local):
        step = min(dt, t_obs - t)
        x, y = rk4_step(x, y, t, step)
        t += step
    streak_positions.append((x, y))

streak_x = [p[0] for p in streak_positions]
streak_y = [p[1] for p in streak_positions]

plt.figure(figsize=(10,6))
plt.title(f"Streakline at t = {t_obs:.2f} s")
plt.xlabel("x"); plt.ylabel("y")
plt.plot(streak_x, streak_y, linewidth=1.5)
plt.scatter([source[0]], [source[1]], s=40, label='source')
plt.scatter([0.0], [0.0], marker='x', s=60)
plt.xlim(xmin, xmax); plt.ylim(ymin, ymax)
plt.gca().set_aspect('equal', adjustable='box')
plt.grid(alpha=0.25)
plt.legend()
plt.tight_layout()
plt.show()

     

